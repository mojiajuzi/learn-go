## 数组和切片

### 数组
数组是一个单一元素类型，长度固定的元素序列，如下

```go
var x [5]int
x[4] = 100
```

和`strings`一样,数组的下标是从`0`开始计数的，　由于数组的长度是固定的，对数组的元素进行删减操作将会比较繁琐，因此比较常用的是对数组进行更高层次的封装的`slice`



#### 切片

切片是对数组的分割，与数组的共同点是可被索引以及含有长度，不同于数组的是，其长度是可变的

```go
var x []float64
```

切片的声明和数组的声明唯一的不同就是，切片的声明在括号中没有长度的限制，如上就声明了一个长度为0的切片，这个时候是不能对切片进行任何的操作

如果需要创建一个切片，应该使用内置的`make`函数:

```go
x := make([]float, 5)
```

如上创建了一个与底层数组(长度为5)相关联的切片,切片总是和数组进行相关联，因此切片的长度不能比其底层的数组长，只能小于或等于其底层数组长度

当然，`make`函数还接受第三个参数

```go
x := make([]float64, 5, 10)
```

其中，10代表的是其底层数组的容量，因此这里引出了切片的两个重要的属性：长度和容量。

- 长度，切片所包含的元素的数量，可以使用`len(s)`来进行查看
- 容量，切片的第一个元素对应的底层数组位置的开始，到数组末尾的元素的元素数量,使用`cap(s)`进行查看

另外一种创建切片的方法是使用`[low:high]`表达式:

```go
arr := [5]float64{1,2,3,4,5}
x := arr[0:5]
```

需要注意的是，该表达式是一个左开右闭的，只会包含左边的区间，更为便利的是我们可以省略`low`或者`high`,或者两者都进行省略

对于索引操作，Go内置了两个与切片相关的操作函数`append`和`copy`函数

##### append

该函数添加元素到切片的末尾

- 如果切片的容量足够，那么元素将会被直接添加到切片末尾，切片长度改变，容量不变
- 如果切片容量不足，将会创建一个新的数组，切片中的所有元素将会被复制到新数组中，新添加的元素继续增加到新数组的末尾，并且返回一个新的切片

##### copy

```go
copy(dst, src []Type)
```

将`src`中的元素复制到`dst`中，如果两个切片的长度不一样，那么两者之中较短的那一个将会被当做接受元素的目标

```go
func main () {
  slice1 := []int{1,2,3}
  slice2 := make([]int, 2)
  copy(slice2,slice1)
  fmt.Println(slice1, slice2)
}
```

如上所示，本意是将`slice1`中的值复制到`slice２`中，但是`slice2`的容量为２，小于`slice1`中的元素的长度，所以只有讲`slice1`复制到`slice2`中

切片的一个典型应用是表示一个子元素的一个列表，这样就可以通过下标快速检索一个元素





